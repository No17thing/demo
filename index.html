<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng Ph√°t Hi·ªán L·ª´a ƒê·∫£o & C·∫£nh B√°o S·ªõm ƒêa K√™nh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .system-architecture {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            padding: 30px;
        }

        .layer {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .layer:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .ui-layer {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }

        .ai-layer {
            background: linear-gradient(135deg, #fd79a8, #e84393);
            color: white;
        }

        .analysis-layer {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: white;
        }

        .processing-channels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .channel {
            background: linear-gradient(135deg, #55a3ff, #003d82);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .channel:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .input-data {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .demo-section {
            padding: 30px;
            border-top: 3px solid #ddd;
        }

        .demo-controls{
  max-width: 1200px;      /* tu·ª≥ b·∫°n, 1100‚Äì1300 ƒë·ªÅu ok */
  margin: 0 auto;         /* ‚úÖ cƒÉn gi·ªØa */
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 24px;
  align-items: stretch;
}

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-panel h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }

        .input-group input, .input-group textarea, .input-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus, .input-group textarea:focus, .input-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }

        .btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.4);
        }

        .results-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #28a745;
        }

        .alert {
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }

        .alert-low { background: #d4edda; color: #155724; border-left: 4px solid #28a745; }
        .alert-medium { background: #fff3cd; color: #856404; border-left: 4px solid #ffc107; }
        .alert-high { background: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }
        .alert-critical { background: #f5c6cb; color: #491217; border-left: 4px solid #8b0000; animation: pulse 1s infinite; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-left: 4px solid #007bff;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }

        .metric-label {
            color: #6c757d;
            margin-top: 5px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active { background: #28a745; animation: pulse 2s infinite; }
        .status-warning { background: #ffc107; }
        .status-danger { background: #dc3545; }

        .log-panel {
            background: #212529;
            color: #28a745;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            font-size: 12px;
        }

        .timestamp {
            color: #6c757d;
        }

        .integration-panel{
    grid-column: 1 / -1;
    position: relative;
    background: linear-gradient(135deg, rgba(102,126,234,0.12), rgba(118,75,162,0.10));
    border: 1.5px solid #e9ecef;
    border-radius: 12px;
    padding: 22px;
    box-shadow: 0 8px 18px rgba(0,0,0,0.08);
    color: #212529;
}

/* vi·ªÅn nh·∫•n nh·∫π b√™n tr√°i (thay cho vi·ªÅn h·ªìng g·∫Øt) */
.integration-panel::before{
    content:"";
    position:absolute;
    left:0;
    top:0;
    bottom:0;
    width:6px;
    border-radius: 12px 0 0 12px;
    background: linear-gradient(180deg, #667eea, #764ba2);
    opacity: 0.9;
}

.integration-panel h3{
    margin-bottom: 10px;
    color:#343a40;
}

.integration-panel .input-group label{
    font-weight: 600;
    color:#495057;
    line-height: 1.4;
}

/* ‚úÖ N√∫t trong panel: ƒë·ªìng b·ªô n√∫t xanh, th√™m glow nh·∫π */
.integration-panel .btn{
    background: linear-gradient(135deg, #1e7bff, #0056b3);
    font-size: 16px;
    border-radius: 10px;
    padding: 14px 18px;
    box-shadow: 0 10px 22px rgba(0,123,255,0.25);
}

.integration-panel .btn:hover{
    transform: translateY(-2px);
    box-shadow: 0 14px 28px rgba(0,123,255,0.32);
}

        /* Visualization styles */
        .visualization-container {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .entity-graph {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            text-align: center;
        }

        .entity-node {
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
        }

        .node-url { background: #3498db; }
        .node-sms { background: #9b59b6; }
        .node-call { background: #e74c3c; }

        .connection-line {
            height: 3px;
            background: #2ecc71;
            margin: 10px 0;
            position: relative;
        }

        .connection-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            border: 1px solid #ddd;
        }

        @media (max-width: 768px) {
            .processing-channels {
                grid-template-columns: 1fr;
            }
            
            .demo-controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .entity-graph {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üõ°Ô∏è H·ªÜ TH·ªêNG PH√ÅT HI·ªÜN L·ª™A ƒê·∫¢O & C·∫¢NH B√ÅO S·ªöM ƒêA K√äNH</h1>
            
        </div>

        <!-- System Architecture Display -->
        <div class="system-architecture">
            <!-- UI & Alert Layer -->
            <div class="layer ui-layer">
                <h2>üñ•Ô∏è L·ªöP GIAO DI·ªÜN & C·∫¢NH B√ÅO</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <h4>‚Ä¢ B·∫£ng ƒëi·ªÅu khi·ªÉn Qu·∫£n tr·ªã</h4>
                        <p>Theo d√µi v√† ki·ªÉm so√°t th·ªùi gian th·ª±c</p>
                    </div>
                    <div>
                        <h4>‚Ä¢ C·∫£nh b√°o Ng∆∞·ªùi d√πng</h4>
                        <p>Th√¥ng b√°o v√† c·∫£nh b√°o t·ª©c th·ªùi</p>
                    </div>
                </div>
            </div>

            <!-- AI Risk Scoring & Decision Engine -->
            <div class="layer ai-layer">
                <h2>üß† B·ªò ƒê√ÅNH GI√Å R·ª¶I RO & QUY·∫æT ƒê·ªäNH AI</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <h4>‚Ä¢ ƒê√°nh gi√° R·ªßi ro Th√≠ch ·ª©ng</h4>
                        <p>Thu·∫≠t to√°n h·ªçc m√°y th√¥ng minh</p>
                    </div>
                    <div>
                        <h4>‚Ä¢ K√≠ch ho·∫°t C·∫£nh b√°o S·ªõm</h4>
                        <p>Ph√°t hi·ªán m·ªëi ƒëe d·ªça d·ª± ƒëo√°n</p>
                    </div>
                </div>
            </div>

            <!-- Cross-Channel Analysis -->
            <div class="layer analysis-layer">
                <h2>üîó PH√ÇN T√çCH LI√äN K√äNH</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 15px;">
                    <div>
                        <h4>‚Ä¢ ƒê·ªì th·ªã Quan h·ªá Th·ª±c th·ªÉ</h4>
                        <p>√Ånh x·∫° m·ªëi ƒëe d·ªça ƒë∆∞·ª£c k·∫øt n·ªëi</p>
                    </div>
                    <div>
                        <h4>‚Ä¢ Ph√¢n t√≠ch H√†nh tr√¨nh/Chu·ªói Ng∆∞·ªùi d√πng</h4>
                        <p>Nh·∫≠n di·ªán m·∫´u h√†nh vi</p>
                    </div>
                </div>
            </div>

            <!-- Processing Channels -->
            <div class="processing-channels">
                <div class="channel" onclick="selectChannel('url')">
                    <h3>üåê URL / WEBSITE</h3>
                    <h4>TI·ªÄN X·ª¨ L√ù</h4>
                    <p>Ph√°t hi·ªán li√™n k·∫øt ƒë·ªôc h·∫°i</p>
                </div>
                <div class="channel" onclick="selectChannel('sms')">
                    <h3>üì± SMS / EMAIL</h3>
                    <h4>TI·ªÄN X·ª¨ L√ù</h4>
                    <p>Ph√¢n t√≠ch & l·ªçc n·ªôi dung</p>
                </div>
                <div class="channel" onclick="selectChannel('call')">
                    <h3>üìû CU·ªòC G·ªåI L·ª™A ƒê·∫¢O</h3>
                    <h4>TI·ªÄN X·ª¨ L√ù</h4>
                    <p>Ph√¢n t√≠ch m·∫´u gi·ªçng n√≥i</p>
                </div>
            </div>

            <!-- Multi-Channel Input Data -->
            <div class="input-data">
                <h2>üìä D·ªÆ LI·ªÜU ƒê·∫¶U V√ÄO ƒêA K√äNH</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                    <div>
                        <h4>‚Ä¢ URL / Website</h4>
                        <p>Ph√¢n t√≠ch t√™n mi·ªÅn, qu√©t n·ªôi dung</p>
                    </div>
                    <div>
                        <h4>‚Ä¢ SMS / Email</h4>
                        <p>N·ªôi dung tin nh·∫Øn, th√¥ng tin ng∆∞·ªùi g·ª≠i</p>
                    </div>
                    <div>
                        <h4>‚Ä¢ Si√™u d·ªØ li·ªáu Cu·ªôc g·ªçi</h4>
                        <p>S·ªë ƒëi·ªán tho·∫°i, ƒë·ªô d√†i, b·∫£n ghi √¢m</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Interactive Demo Section -->
        <div class="demo-section">
            <h2 style="text-align: center; margin-bottom: 30px; color: #495057;">üöÄ DEMO T∆Ø∆†NG T√ÅC</h2>
            
            <!-- Demo Controls -->
            <div class="demo-controls">
                <!-- URL/Website Input -->
                <div class="control-panel">
                    <h3>üåê Ph√¢n t√≠ch URL/Website</h3>
                    <div class="input-group">
                        <label for="urlInput">URL Website:</label>
                        <input type="url" id="urlInput" placeholder="https://trang-web-dang-ng·ªù.com" value="https://phishing-bank-login.fake">
                    </div>
                    <div class="input-group">
                        <label for="pageTitle">Ti√™u ƒë·ªÅ Trang:</label>
                        <input type="text" id="pageTitle" placeholder="Ti√™u ƒë·ªÅ trang" value="Kh·∫©n c·∫•p: X√°c minh T√†i kho·∫£n Ng√¢n h√†ng C·ªßa B·∫°n">
                    </div>
                    <div class="input-group">
                        <label for="pageContent">N·ªôi dung Trang:</label>
                        <textarea id="pageContent" rows="3" placeholder="N·ªôi dung trang...">Nh·∫•p v√†o ƒë√¢y ngay l·∫≠p t·ª©c ƒë·ªÉ x√°c minh t√†i kho·∫£n c·ªßa b·∫°n ho·∫∑c n√≥ s·∫Ω b·ªã t·∫°m ng·ª´ng trong v√≤ng 24 gi·ªù! Li√™n h·ªá h·ªó tr·ª£: +84 123 456 789</textarea>
                    </div>
                    <button class="btn" onclick="analyzeURL()">Ph√¢n t√≠ch Website</button>
                </div>

                <!-- SMS/Email Input -->
                <div class="control-panel">
                    <h3>üì± Ph√¢n t√≠ch SMS/Email</h3>
                    <div class="input-group">
                        <label for="smsType">Lo·∫°i:</label>
                        <select id="smsType">
                            <option value="sms">SMS</option>
                            <option value="email">Email</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="sender">Ng∆∞·ªùi g·ª≠i:</label>
                        <input type="text" id="sender" placeholder="nguoigui@example.com" value="no-reply@bank-security.fake">
                    </div>
                    <div class="input-group">
                        <label for="messageContent">N·ªôi dung Tin nh·∫Øn:</label>
                        <textarea id="messageContent" rows="3" placeholder="N·ªôi dung tin nh·∫Øn...">KH·∫®N C·∫§P: T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã x√¢m ph·∫°m. Nh·∫•p v√†o li√™n k·∫øt n√†y ngay l·∫≠p t·ª©c: https://phishing-bank-login.fake ho·∫∑c g·ªçi +84 123 456 789 ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.</textarea>
                    </div>
                    <button class="btn" onclick="analyzeSMS()">Ph√¢n t√≠ch Tin nh·∫Øn</button>
                </div>

                <!-- Scam Call Input -->
                <div class="control-panel">
                    <h3>üìû Ph√¢n t√≠ch Cu·ªôc G·ªçi L·ª´a ƒê·∫£o</h3>
                    <div class="input-group">
                        <label for="phoneNumber">S·ªë ƒêi·ªán Tho·∫°i:</label>
                        <input type="tel" id="phoneNumber" placeholder="+84-xxx-xxxx" value="+84 123 456 789">
                    </div>
                    <div class="input-group">
                        <label for="callDuration">Th·ªùi l∆∞·ª£ng (gi√¢y):</label>
                        <input type="number" id="callDuration" placeholder="120" value="45">
                    </div>
                    <div class="input-group">
                        <label for="transcript">B·∫£n ghi Cu·ªôc g·ªçi:</label>
                        <textarea id="transcript" rows="3" placeholder="B·∫£n ghi cu·ªôc g·ªçi...">Xin ch√†o, ƒë√¢y l√† t·ª´ b·ªô ph·∫≠n an ninh ng√¢n h√†ng c·ªßa b·∫°n. Ch√∫ng t√¥i ƒë√£ ph√°t hi·ªán ho·∫°t ƒë·ªông ƒë√°ng ng·ªù tr√™n t√†i kho·∫£n c·ªßa b·∫°n. Vui l√≤ng truy c·∫≠p https://phishing-bank-login.fake v√† cung c·∫•p s·ªë t√†i kho·∫£n v√† m√£ PIN ƒë·ªÉ x√°c minh danh t√≠nh c·ªßa b·∫°n.</textarea>
                    </div>
                    <button class="btn" onclick="analyzeCall()">Ph√¢n t√≠ch Cu·ªôc G·ªçi</button>
                </div>

                <!-- üÜï PH√ÇN T√çCH T√çCH H·ª¢P ƒêA K√äNH -->
                <div class="control-panel integration-panel">
                    <h3>üîó PH√ÇN T√çCH T√çCH H·ª¢P ƒêA K√äNH</h3>
                    <div class="input-group">
  <p style="margin:0; color:#495057; font-weight:600;">
    K·∫øt h·ª£p d·ªØ li·ªáu t·ª´ c·∫£ 3 k√™nh ƒë·ªÉ ph√°t hi·ªán chi·∫øn d·ªãch l·ª´a ƒë·∫£o ph·ªëi h·ª£p
  </p>
</div>
                    <button class="btn" onclick="analyzeCrossChannel()">
                        üîç Ph√¢n T√≠ch T√≠ch H·ª£p ƒêa K√™nh
                    </button>
                </div>
            </div>

            <!-- Visualization Panel -->
            <div class="visualization-container" id="visualization">
                <h3>üìä TR·ª∞C QUAN H√ìA M·ªêI QUAN H·ªÜ ƒêA K√äNH</h3>
                <div class="entity-graph" id="entityGraph">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <!-- Results Panel -->
            <div class="results-panel">
                <h3>üìä K·∫øt Qu·∫£ Ph√¢n T√≠ch</h3>
                <div id="alertsContainer">
                    <div class="alert alert-medium">
                        <span class="status-indicator status-warning"></span>
                        H·ªá th·ªëng s·∫µn s√†ng ph√¢n t√≠ch. Vui l√≤ng ch·ªçn k√™nh v√† nh·∫≠p d·ªØ li·ªáu b√™n tr√™n.
                    </div>
                </div>

                <!-- Metrics Dashboard -->
                <div class="metrics">
                    <div class="metric-card">
                        <div class="metric-value" id="riskScore">0</div>
                        <div class="metric-label">ƒêi·ªÉm R·ªßi ro</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="threatsDetected">0</div>
                        <div class="metric-label">M·ªëi ƒëe d·ªça ƒê√£ Ph√°t hi·ªán</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="channelsAnalyzed">0</div>
                        <div class="metric-label">K√™nh ƒê√£ Ph√¢n t√≠ch</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="accuracy">98.5%</div>
                        <div class="metric-label">ƒê·ªô Ch√≠nh x√°c</div>
                    </div>
                </div>

                <!-- System Log -->
                <div class="log-panel" id="systemLog">
                    <div class="log-entry">
                        <span class="timestamp">[2024-12-13 18:08:49]</span> H·ªá th·ªëng ƒë√£ kh·ªüi t·∫°o th√†nh c√¥ng
                    </div>
                    <div class="log-entry">
                        <span class="timestamp">[2024-12-13 18:08:49]</span> B·ªô ƒë√°nh gi√° R·ªßi ro AI: HO·∫†T ƒê·ªòNG
                    </div>
                    <div class="log-entry">
                        <span class="timestamp">[2024-12-13 18:08:49]</span> Ph√¢n t√≠ch Li√™n k√™nh: S·∫¥N S√ÄNG
                    </div>
                    <div class="log-entry">
                        <span class="timestamp">[2024-12-13 18:08:49]</span> H·ªá th·ªëng C·∫£nh b√°o S·ªõm: ƒêANG GI√ÅM S√ÅT
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== BI·∫æN TO√ÄN C·ª§C ==========
        let threatsDetected = 0;
        let channelsAnalyzed = 0;
        let entityGraph = {
            channels: {
    url:  { phones: new Set(), urls: new Set(), keywords: new Set() },
    sms:  { phones: new Set(), urls: new Set(), keywords: new Set() },
    call: { phones: new Set(), urls: new Set(), keywords: new Set() }
  }
        };
		
		function resetCrossChannelState() {
  Object.keys(entityGraph.channels).forEach(ch => {
    entityGraph.channels[ch].phones.clear();
    entityGraph.channels[ch].urls.clear();
    entityGraph.channels[ch].keywords.clear();
  });
}


        // ========== H√ÄM TI·ªÜN √çCH ==========
        function addLog(message) {
            const logPanel = document.getElementById('systemLog');
            const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            logPanel.appendChild(logEntry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        function updateMetrics(riskScore) {
            document.getElementById('riskScore').textContent = riskScore;
            document.getElementById('threatsDetected').textContent = threatsDetected;
            document.getElementById('channelsAnalyzed').textContent = channelsAnalyzed;
        }

        function showAlert(level, message, details = []) {
            const alertsContainer = document.getElementById('alertsContainer');
            alertsContainer.innerHTML = '';
            
            const alert = document.createElement('div');
            alert.className = `alert alert-${level}`;
            
            let statusClass = 'status-active';
            if (level === 'high' || level === 'critical') statusClass = 'status-danger';
            else if (level === 'medium') statusClass = 'status-warning';
            
            let alertContent = `<span class="status-indicator ${statusClass}"></span>${message}`;
            
            if (details.length > 0) {
                alertContent += '<ul style="margin-top: 10px; padding-left: 20px;">';
                details.forEach(detail => {
                    alertContent += `<li>${detail}</li>`;
                });
                alertContent += '</ul>';
            }
            
            alert.innerHTML = alertContent;
            alertsContainer.appendChild(alert);
        }

        // ========== TR√çCH XU·∫§T TH·ª∞C TH·ªÇ ==========
        function extractEntitiesFromText(text, source) {
  const phoneRegex = /(\+?84|0)(\s?[0-9]){9,10}/g;
  const urlRegex = /(https?:\/\/[^\s]+)/g;

  const phones = (text.match(phoneRegex) || []);
  const urls = (text.match(urlRegex) || []);

  const scamKeywords = [
    'kh·∫©n c·∫•p','ngay l·∫≠p t·ª©c','t√†i kho·∫£n','x√°c minh',
    'c·∫£nh b√°o','l·ª´a ƒë·∫£o','ng√¢n h√†ng','m√£ pin','otp'
  ];

  const keywords = scamKeywords.filter(k =>
    text.toLowerCase().includes(k)
  );

  phones.forEach(p => entityGraph.channels[source].phones.add(p));
  urls.forEach(u => entityGraph.channels[source].urls.add(u));
  keywords.forEach(k => entityGraph.channels[source].keywords.add(k));
}

        // ========== T√çNH ƒêI·ªÇM R·ª¶I RO ==========
        function calculateRiskScore(factors) {
            let score = 0;
            let riskFactors = [];
            
            // URL Analysis
            if (factors.suspiciousKeywords) {
                score += 25;
                riskFactors.push('Ph√°t hi·ªán t·ª´ kh√≥a ƒë√°ng ng·ªù');
            }
            if (factors.noSSL) {
                score += 20;
                riskFactors.push('Kh√¥ng c√≥ ch·ª©ng ch·ªâ SSL');
            }
            if (factors.suspiciousDomain) {
                score += 30;
                riskFactors.push('M·∫´u t√™n mi·ªÅn ƒë√°ng ng·ªù');
            }
            if (factors.redirects > 2) {
                score += 15;
                riskFactors.push('Nhi·ªÅu l·∫ßn chuy·ªÉn h∆∞·ªõng');
            }
            
            // SMS/Email Analysis
            if (factors.urgencyKeywords && factors.urgencyKeywords.length > 0) {
                score += 20;
                riskFactors.push(`T·ª´ kh√≥a kh·∫©n c·∫•p: ${factors.urgencyKeywords.join(', ')}`);
            }
            if (factors.hasLinks) {
                score += 15;
                riskFactors.push('Ch·ª©a li√™n k·∫øt ƒë√°ng ng·ªù');
            }
            if (factors.financialKeywords && factors.financialKeywords.length > 0) {
                score += 25;
                riskFactors.push('Ph√°t hi·ªán t·ª´ kh√≥a t√†i ch√≠nh');
            }
            if (factors.suspiciousSender) {
                score += 20;
                riskFactors.push('T√™n mi·ªÅn ng∆∞·ªùi g·ª≠i ƒë√°ng ng·ªù');
            }
            
            // Call Analysis
            if (factors.shortDuration && factors.callDuration < 60) {
                score += 15;
                riskFactors.push('Cu·ªôc g·ªçi ng·∫Øn ƒë√°ng ng·ªù');
            }
            if (factors.pressureTactics) {
                score += 30;
                riskFactors.push('Ph√°t hi·ªán chi·∫øn thu·∫≠t g√¢y √°p l·ª±c');
            }
            if (factors.requestsPersonalInfo) {
                score += 35;
                riskFactors.push('Y√™u c·∫ßu th√¥ng tin c√° nh√¢n');
            }
            
            return { score: Math.min(score, 100), factors: riskFactors };
        }

        // ========== PH√ÇN T√çCH T·ª™NG K√äNH ==========
        function analyzeURL() {
            channelsAnalyzed++;
            addLog('ƒêang b·∫Øt ƒë·∫ßu ph√¢n t√≠ch URL/Website...');
            
            const url = document.getElementById('urlInput').value;
            const title = document.getElementById('pageTitle').value;
            const content = document.getElementById('pageContent').value;
            
            // Tr√≠ch xu·∫•t th·ª±c th·ªÉ
            const entities = extractEntitiesFromText(url + ' ' + title + ' ' + content, 'url');
            
            // M√¥ ph·ªèng ph√¢n t√≠ch
            const factors = {
                suspiciousKeywords: /kh·∫©n c·∫•p|x√°c minh|t·∫°m ng·ª´ng|nh·∫•p v√†o ƒë√¢y|th·ªùi gian c√≥ h·∫°n/i.test(content + title),
                noSSL: !url.startsWith('https://'),
                suspiciousDomain: /fake|phishing|scam/.test(url),
                redirects: Math.floor(Math.random() * 5)
            };
            
            const analysis = calculateRiskScore(factors);
            
            setTimeout(() => {
                if (analysis.score > 70) {
                    threatsDetected++;
                    showAlert('critical', `üö® PH√ÅT HI·ªÜN M·ªêI ƒêE D·ªåA NGHI√äM TR·ªåNG - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`NGHI√äM TR·ªåNG: ƒê√£ ph√°t hi·ªán website ƒë·ªôc h·∫°i - ${url}`);
                } else if (analysis.score > 40) {
                    threatsDetected++;
                    showAlert('high', `‚ö†Ô∏è PH√ÅT HI·ªÜN R·ª¶I RO CAO - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`C·∫¢NH B√ÅO: ƒê√£ ph√°t hi·ªán website ƒë√°ng ng·ªù - ${url}`);
                } else if (analysis.score > 20) {
                    showAlert('medium', `‚ö° R·ª¶I RO TRUNG B√åNH - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`TH√îNG TIN: Website c√≥ kh·∫£ nƒÉng ƒë√°ng ng·ªù - ${url}`);
                } else {
                    showAlert('low', `‚úÖ R·ª¶I RO TH·∫§P - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, ['Website c√≥ v·∫ª h·ª£p ph√°p']);
                    addLog(`TH√îNG TIN: Ph√¢n t√≠ch website ho√†n t·∫•t - ${url} c√≥ v·∫ª an to√†n`);
                }
                
                updateMetrics(analysis.score);
                addLog('Ph√¢n t√≠ch URL/Website ƒë√£ ho√†n t·∫•t');
            }, 1500);
        }

        function analyzeSMS() {
            channelsAnalyzed++;
            addLog('ƒêang b·∫Øt ƒë·∫ßu ph√¢n t√≠ch SMS/Email...');
            
            const type = document.getElementById('smsType').value;
            const sender = document.getElementById('sender').value;
            const content = document.getElementById('messageContent').value;
            
            // Tr√≠ch xu·∫•t th·ª±c th·ªÉ
            const entities = extractEntitiesFromText(content, 'sms');
            
            const urgencyKeywords = ['kh·∫©n c·∫•p', 'ngay l·∫≠p t·ª©c', 'g·∫•p', 'kh·∫©n', 'h·∫øt h·∫°n'].filter(word => 
                content.toLowerCase().includes(word)
            );
            
            const financialKeywords = ['ng√¢n h√†ng', 't√†i kho·∫£n', 't√≠n d·ª•ng', 'thanh to√°n', 'ti·ªÅn', 'x√°c minh'].filter(word => 
                content.toLowerCase().includes(word)
            );
            
            const factors = {
                urgencyKeywords,
                hasLinks: /http[s]?:\/\//.test(content),
                financialKeywords,
                suspiciousSender: /fake|scam|phishing/.test(sender)
            };
            
            const analysis = calculateRiskScore(factors);
            
            setTimeout(() => {
                if (analysis.score > 70) {
                    threatsDetected++;
                    showAlert('critical', `üö® PH√ÅT HI·ªÜN ${type.toUpperCase()} L·ª™A ƒê·∫¢O - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`NGHI√äM TR·ªåNG: ${type} l·ª´a ƒë·∫£o t·ª´ ${sender}`);
                } else if (analysis.score > 40) {
                    threatsDetected++;
                    showAlert('high', `‚ö†Ô∏è ${type.toUpperCase()} ƒê√ÅNG NG·ªú - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`C·∫¢NH B√ÅO: ${type} ƒë√°ng ng·ªù t·ª´ ${sender}`);
                } else if (analysis.score > 20) {
                    showAlert('medium', `‚ö° ${type.toUpperCase()} R·ª¶I RO TRUNG B√åNH - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`TH√îNG TIN: ${type} c√≥ kh·∫£ nƒÉng ƒë√°ng ng·ªù t·ª´ ${sender}`);
                } else {
                    showAlert('low', `‚úÖ ${type.toUpperCase()} H·ª¢P PH√ÅP - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, ['Tin nh·∫Øn c√≥ v·∫ª h·ª£p ph√°p']);
                    addLog(`TH√îNG TIN: ${type} t·ª´ ${sender} c√≥ v·∫ª an to√†n`);
                }
                
                updateMetrics(analysis.score);
                addLog(`Ph√¢n t√≠ch ${type.toUpperCase()} ƒë√£ ho√†n t·∫•t`);
            }, 1200);
        }

        function analyzeCall() {
            channelsAnalyzed++;
            addLog('ƒêang b·∫Øt ƒë·∫ßu ph√¢n t√≠ch Cu·ªôc g·ªçi L·ª´a ƒë·∫£o...');
            
            const phoneNumber = document.getElementById('phoneNumber').value;
            const duration = parseInt(document.getElementById('callDuration').value);
            const transcript = document.getElementById('transcript').value;
            
            // Tr√≠ch xu·∫•t th·ª±c th·ªÉ
            const entities = extractEntitiesFromText(transcript + ' ' + phoneNumber, 'call');
            
            const factors = {
                shortDuration: duration < 60,
                pressureTactics: /kh·∫©n c·∫•p|ngay l·∫≠p t·ª©c|b√¢y gi·ªù|h√¥m nay/.test(transcript.toLowerCase()),
                requestsPersonalInfo: /t√†i kho·∫£n|m√£ pin|m·∫≠t kh·∫©u|ssn|b·∫£o hi·ªÉm x√£ h·ªôi/.test(transcript.toLowerCase()),
                callDuration: duration
            };
            
            const analysis = calculateRiskScore(factors);
            
            setTimeout(() => {
                if (analysis.score > 70) {
                    threatsDetected++;
                    showAlert('critical', `üö® PH√ÅT HI·ªÜN CU·ªòC G·ªåI L·ª™A ƒê·∫¢O - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`NGHI√äM TR·ªåNG: ƒê√£ ph√°t hi·ªán cu·ªôc g·ªçi l·ª´a ƒë·∫£o t·ª´ ${phoneNumber}`);
                } else if (analysis.score > 40) {
                    threatsDetected++;
                    showAlert('high', `‚ö†Ô∏è CU·ªòC G·ªåI ƒê√ÅNG NG·ªú - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`C·∫¢NH B√ÅO: Cu·ªôc g·ªçi ƒë√°ng ng·ªù t·ª´ ${phoneNumber}`);
                } else if (analysis.score > 20) {
                    showAlert('medium', `‚ö° CU·ªòC G·ªåI R·ª¶I RO TRUNG B√åNH - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, analysis.factors);
                    addLog(`TH√îNG TIN: Cu·ªôc g·ªçi c√≥ kh·∫£ nƒÉng ƒë√°ng ng·ªù t·ª´ ${phoneNumber}`);
                } else {
                    showAlert('low', `‚úÖ CU·ªòC G·ªåI H·ª¢P PH√ÅP - ƒêi·ªÉm R·ªßi ro: ${analysis.score}/100`, ['Cu·ªôc g·ªçi c√≥ v·∫ª h·ª£p ph√°p']);
                    addLog(`TH√îNG TIN: Cu·ªôc g·ªçi t·ª´ ${phoneNumber} c√≥ v·∫ª an to√†n`);
                }
                
                updateMetrics(analysis.score);
                addLog('Ph√¢n t√≠ch cu·ªôc g·ªçi ƒë√£ ho√†n t·∫•t');
            }, 1800);
        }
// ===== Helper: normalize phone & url (demo-friendly) =====
function normalizePhone(raw) {
  if (!raw) return '';
  let s = String(raw).trim();
  s = s.replace(/[^\d+]/g, ''); // gi·ªØ s·ªë v√† +
  // ƒë∆∞a v·ªÅ d·∫°ng +84xxxxxxxxx n·∫øu c√≥ th·ªÉ
  if (s.startsWith('+84')) {
    s = '+84' + s.slice(3).replace(/\D/g, '');
  } else if (s.startsWith('84')) {
    s = '+84' + s.slice(2).replace(/\D/g, '');
  } else if (s.startsWith('0')) {
    s = '+84' + s.slice(1).replace(/\D/g, '');
  } else {
    // fallback
    s = s.replace(/\D/g, '');
  }
  return s;
}

function normalizeUrl(raw) {
  if (!raw) return '';
  try {
    const u = new URL(raw.trim());
    const host = u.hostname.toLowerCase();
    // demo: b·ªè query/hash ƒë·ªÉ d·ªÖ match
    const path = (u.pathname || '').replace(/\/+$/, ''); // b·ªè slash cu·ªëi
    return `${u.protocol}//${host}${path}`;
  } catch {
    // n·∫øu kh√¥ng parse ƒë∆∞·ª£c, tr·∫£ v·ªÅ b·∫£n th∆∞·ªùng h√≥a ƒë∆°n gi·∫£n
    return raw.trim().toLowerCase().replace(/\/+$/, '');
  }
}

// ===== Helper: extract entities + normalize v√†o entityGraph =====
function extractEntitiesFromTextNormalized(text, source) {
  const phoneRegex = /(\+?84|0)(\s?[0-9]){9,10}/g;
  const urlRegex = /(https?:\/\/[^\s]+)/g;

  const phones = (text.match(phoneRegex) || []).map(normalizePhone).filter(Boolean);
  const urls = (text.match(urlRegex) || []).map(normalizeUrl).filter(Boolean);

  const scamKeywords = [
    'kh·∫©n c·∫•p','ngay l·∫≠p t·ª©c','t√†i kho·∫£n','x√°c minh',
    'c·∫£nh b√°o','l·ª´a ƒë·∫£o','ng√¢n h√†ng','m√£ pin','otp','m·∫≠t kh·∫©u','ƒëƒÉng nh·∫≠p'
  ];
  const lower = text.toLowerCase();
  const keywords = scamKeywords.filter(k => lower.includes(k));

  phones.forEach(p => entityGraph.channels[source].phones.add(p));
  urls.forEach(u => entityGraph.channels[source].urls.add(u));
  keywords.forEach(k => entityGraph.channels[source].keywords.add(k));
}

// ===== Helper: per-channel analysis (explainable) =====
function analyzeURLChannel(url, title, content) {
  const combined = `${url} ${title} ${content}`.toLowerCase();

  const issues = [];
  let score = 0;

  const suspiciousDomain = /fake|phishing|scam/.test(url);
  if (suspiciousDomain) { score += 30; issues.push('T√™n mi·ªÅn c√≥ m·∫´u ƒë√°ng ng·ªù (fake/phishing/scam)'); }

  const urgency = /kh·∫©n c·∫•p|ngay l·∫≠p t·ª©c|t·∫°m ng·ª´ng|24 gi·ªù|th·ªùi gian c√≥ h·∫°n|x√°c minh/.test(combined);
  if (urgency) { score += 20; issues.push('N·ªôi dung t·∫°o √°p l·ª±c th·ªùi gian / y√™u c·∫ßu x√°c minh g·∫•p'); }

  const asksSensitive = /m√£ pin|otp|m·∫≠t kh·∫©u|cung c·∫•p.*pin|cung c·∫•p.*otp/.test(combined);
  if (asksSensitive) { score += 35; issues.push('C√≥ d·∫•u hi·ªáu y√™u c·∫ßu th√¥ng tin nh·∫°y c·∫£m (PIN/OTP/m·∫≠t kh·∫©u)'); }

  const noSSL = !url.startsWith('https://');
  if (noSSL) { score += 15; issues.push('URL kh√¥ng d√πng HTTPS (thi·∫øu SSL)'); }

  const hasPhoneMention = /(\+?84|0)(\s?[0-9]){9,10}/.test(combined);
  if (hasPhoneMention) { score += 10; issues.push('Trang c√≥ nh·∫Øc s·ªë ƒëi·ªán tho·∫°i ‚Äúh·ªó tr·ª£‚Äù (th∆∞·ªùng d√πng ƒë·ªÉ d·∫´n d·ª•)'); }

  return { score: Math.min(score, 100), issues };
}

function analyzeSMSChannel(sender, content, typeLabel) {
  const lower = `${sender} ${content}`.toLowerCase();

  const issues = [];
  let score = 0;

  const suspiciousSender = /fake|scam|phishing/.test(sender.toLowerCase());
  if (suspiciousSender) { score += 25; issues.push('T√™n mi·ªÅn ng∆∞·ªùi g·ª≠i c√≥ m·∫´u ƒë√°ng ng·ªù (fake/scam/phishing)'); }

  const hasLink = /(https?:\/\/[^\s]+)/.test(content);
  if (hasLink) { score += 20; issues.push('C√≥ ch·ª©a li√™n k·∫øt (link) trong n·ªôi dung'); }

  const urgency = /kh·∫©n c·∫•p|ngay l·∫≠p t·ª©c|g·∫•p|h·∫øt h·∫°n|kh·∫©n/.test(lower);
  if (urgency) { score += 25; issues.push('C√≥ t·ª´ kh√≥a g√¢y √°p l·ª±c/kh·∫©n c·∫•p'); }

  const finance = /ng√¢n h√†ng|t√†i kho·∫£n|thanh to√°n|ti·ªÅn|x√°c minh/.test(lower);
  if (finance) { score += 20; issues.push('N·ªôi dung li√™n quan t√†i ch√≠nh/t√†i kho·∫£n (m·ªìi nh·ª≠ ph·ªï bi·∫øn)'); }

  const hasPhone = /(\+?84|0)(\s?[0-9]){9,10}/.test(lower);
  if (hasPhone) { score += 10; issues.push('C√≥ nh·∫Øc s·ªë ƒëi·ªán tho·∫°i li√™n h·ªá trong tin nh·∫Øn'); }

  return { score: Math.min(score, 100), issues, typeLabel };
}

function analyzeCallChannel(phoneNumber, duration, transcript) {
  const lower = `${phoneNumber} ${transcript}`.toLowerCase();

  const issues = [];
  let score = 0;

  const impersonation = /b·ªô ph·∫≠n an ninh|ng√¢n h√†ng c·ªßa b·∫°n|c∆° quan|c√¥ng an|h·ªó tr·ª£/.test(lower);
  if (impersonation) { score += 25; issues.push('C√≥ d·∫•u hi·ªáu gi·∫£ danh t·ªï ch·ª©c/ƒë∆°n v·ªã ƒë√°ng tin (ng√¢n h√†ng/c∆° quan)'); }

  const pressure = /kh·∫©n c·∫•p|ngay l·∫≠p t·ª©c|b√¢y gi·ªù|h√¥m nay|n·∫øu kh√¥ng/.test(lower);
  if (pressure) { score += 20; issues.push('C√≥ chi·∫øn thu·∫≠t g√¢y √°p l·ª±c (ra quy·∫øt ƒë·ªãnh ngay)'); }

  const asksSensitive = /m√£ pin|otp|m·∫≠t kh·∫©u|s·ªë t√†i kho·∫£n|cung c·∫•p.*pin|cung c·∫•p.*otp/.test(lower);
  if (asksSensitive) { score += 40; issues.push('Y√™u c·∫ßu th√¥ng tin nh·∫°y c·∫£m (PIN/OTP/m·∫≠t kh·∫©u/s·ªë t√†i kho·∫£n)'); }

  const mentionsUrl = /(https?:\/\/[^\s]+)/.test(transcript);
  if (mentionsUrl) { score += 15; issues.push('Cu·ªôc g·ªçi c√≥ nh·∫Øc truy c·∫≠p URL/link'); }

  if (Number.isFinite(duration) && duration < 60) {
    score += 10;
    issues.push('Cu·ªôc g·ªçi ng·∫Øn nh∆∞ng ch·ª©a y√™u c·∫ßu h√†nh ƒë·ªông (m·∫´u ƒë√°ng ng·ªù)');
  }

  return { score: Math.min(score, 100), issues };
}

// ===== Helper: build correlation evidence =====
function getOverlapEntities(type) {
  const map = new Map(); // entity -> [channels]
  Object.keys(entityGraph.channels).forEach(ch => {
    entityGraph.channels[ch][type].forEach(v => {
      if (!map.has(v)) map.set(v, new Set());
      map.get(v).add(ch);
    });
  });

  const overlaps = [];
  map.forEach((chs, entity) => {
    const arr = Array.from(chs);
    if (arr.length > 1) overlaps.push({ entity, channels: arr });
  });
  return overlaps;
}

// tr·ªçng s·ªë correlation: phone/url m·∫°nh h∆°n keyword
function computeCorrelationScore() {
  const findings = [];
  let score = 0;

  const phoneOver = getOverlapEntities('phones');
  const urlOver = getOverlapEntities('urls');
  const keyOver = getOverlapEntities('keywords');

  if (phoneOver.length) {
    score += Math.min(40, phoneOver.length * 20);
    phoneOver.forEach(o => findings.push(`üìû SƒêT tr√πng: "${o.entity}" xu·∫•t hi·ªán ·ªü ${o.channels.join(', ')}`));
  }
  if (urlOver.length) {
    score += Math.min(45, urlOver.length * 25);
    urlOver.forEach(o => findings.push(`üåê URL tr√πng: "${o.entity}" xu·∫•t hi·ªán ·ªü ${o.channels.join(', ')}`));
  }
  if (keyOver.length) {
    score += Math.min(20, keyOver.length * 5);
    keyOver.forEach(o => findings.push(`üîë Th√¥ng ƒëi·ªáp tr√πng: "${o.entity}" l·∫∑p ·ªü ${o.channels.join(', ')}`));
  }

  // Chu·ªói t·∫•n c√¥ng (demo): SMS c√≥ URL + Web nh·∫Øc SƒêT + Call nh·∫Øc URL
  const hasSMSURL = entityGraph.channels.sms.urls.size > 0;
  const hasWebPhone = entityGraph.channels.url.phones.size > 0;
  const hasCallURL = entityGraph.channels.call.urls.size > 0;

  if (hasSMSURL && hasWebPhone) {
    score += 10;
    findings.push('üîÑ Chu·ªói: SMS ch·ª©a URL ‚Üí Website c√≥ SƒêT h·ªó tr·ª£ (m·∫´u d·∫´n d·ª•)');
  }
  if (hasCallURL && hasWebPhone) {
    score += 10;
    findings.push('üîÑ Chu·ªói: Cu·ªôc g·ªçi nh·∫Øc URL ‚Üí Website c√≥ SƒêT (m·∫´u ‚Äúx√°c nh·∫≠n‚Äù/ƒëi·ªÅu h∆∞·ªõng)');
  }

  return { score: Math.min(score, 100), findings };
}

        // ========== üÜï PH√ÇN T√çCH T√çCH H·ª¢P ƒêA K√äNH ==========
        function analyzeCrossChannel() {
  channelsAnalyzed++;
  resetCrossChannelState();
  addLog('üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch t√≠ch h·ª£p ƒëa k√™nh (t√°ch k√™nh + t·ªïng h·ª£p)...');

  // --- l·∫•y input ---
  const url = document.getElementById('urlInput').value || '';
  const pageTitle = document.getElementById('pageTitle').value || '';
  const pageContent = document.getElementById('pageContent').value || '';

  const smsContent = document.getElementById('messageContent').value || '';
  const sender = document.getElementById('sender').value || '';
  const smsType = (document.getElementById('smsType')?.value || 'sms').toUpperCase();

  const callTranscript = document.getElementById('transcript').value || '';
  const callNumberRaw = document.getElementById('phoneNumber').value || '';
  const callNumber = normalizePhone(callNumberRaw);
  const callDuration = parseInt(document.getElementById('callDuration').value, 10);

  // --- extract entity (normalized) ---
  extractEntitiesFromTextNormalized(`${url} ${pageTitle} ${pageContent}`, 'url');
  extractEntitiesFromTextNormalized(`${smsContent} ${sender}`, 'sms');
  extractEntitiesFromTextNormalized(`${callTranscript} ${callNumber}`, 'call');

  // --- ph√¢n t√≠ch ri√™ng t·ª´ng k√™nh (explainable) ---
  const urlRes = analyzeURLChannel(url, pageTitle, pageContent);
  const smsRes = analyzeSMSChannel(sender, smsContent, smsType);
  const callRes = analyzeCallChannel(callNumber, callDuration, callTranscript);

  // --- correlation (ƒëa k√™nh) ---
  const corr = computeCorrelationScore();

  // --- t√≠nh ƒëi·ªÉm t·ªïng: 60% per-channel + 40% correlation ---
  // per-channel: l·∫•y max ho·∫∑c trung b√¨nh c√≥ tr·ªçng s·ªë (·ªü ƒë√¢y d√πng max ƒë·ªÉ ph·∫£n √°nh ‚Äúk√™nh t·ªá nh·∫•t‚Äù)
  const perChannelMax = Math.max(urlRes.score, smsRes.score, callRes.score);
  const finalScore = Math.min(
    100,
    Math.round(perChannelMax * 0.6 + corr.score * 0.4)
  );

  // --- build details output (t√°ch r√µ t·ª´ng k√™nh + t·ªïng h·ª£p) ---
  const details = [];

  // URL
  details.push(`üåê URL/Website (${urlRes.score}/100):`);
  if (urlRes.issues.length) urlRes.issues.forEach(x => details.push(`- ${x}`));
  else details.push('- Kh√¥ng ph√°t hi·ªán t√≠n hi·ªáu ƒë√°ng ng·ªù r√µ r√†ng');

  // SMS/Email
  details.push(`üì± ${smsRes.typeLabel} (${smsRes.score}/100):`);
  if (smsRes.issues.length) smsRes.issues.forEach(x => details.push(`- ${x}`));
  else details.push('- Kh√¥ng ph√°t hi·ªán t√≠n hi·ªáu ƒë√°ng ng·ªù r√µ r√†ng');

  // Call
  details.push(`üìû Cu·ªôc g·ªçi (${callRes.score}/100):`);
  if (callRes.issues.length) callRes.issues.forEach(x => details.push(`- ${x}`));
  else details.push('- Kh√¥ng ph√°t hi·ªán t√≠n hi·ªáu ƒë√°ng ng·ªù r√µ r√†ng');

  // T·ªïng h·ª£p ƒëa k√™nh
  details.push(`üîó T·ªïng h·ª£p ƒëa k√™nh / T∆∞∆°ng quan (${corr.score}/100):`);
  if (corr.findings.length) corr.findings.forEach(x => details.push(`- ${x}`));
  else details.push('- Kh√¥ng th·∫•y tr√πng th·ª±c th·ªÉ ho·∫∑c chu·ªói ph·ªëi h·ª£p r√µ r√†ng');

  // --- show visualization + show final alert ---
  showVisualization();

  setTimeout(() => {
    // c·∫≠p nh·∫≠t threatsDetected d·ª±a tr√™n finalScore (demo)
    if (finalScore >= 70) {
      threatsDetected++;
      showAlert(
        'critical',
        `üö® PH√ÅT HI·ªÜN CHI·∫æN D·ªäCH L·ª™A ƒê·∫¢O ƒêA K√äNH - ƒêi·ªÉm: ${finalScore}/100`,
        details
      );
      addLog('NGHI√äM TR·ªåNG: K·∫øt lu·∫≠n chi·∫øn d·ªãch ƒëa k√™nh (t·ªïng h·ª£p t·ª´ t·ª´ng k√™nh + t∆∞∆°ng quan)');
    } else if (finalScore >= 40) {
      threatsDetected++;
      showAlert(
        'high',
        `‚ö†Ô∏è NGHI NG·ªú CHI·∫æN D·ªäCH ƒêA K√äNH - ƒêi·ªÉm: ${finalScore}/100`,
        details
      );
      addLog('C·∫¢NH B√ÅO: C√≥ d·∫•u hi·ªáu ƒëa k√™nh (theo ph√¢n t√≠ch t√°ch k√™nh + t∆∞∆°ng quan)');
    } else if (finalScore >= 20) {
      showAlert(
        'medium',
        `‚ö° C√ì D·∫§U HI·ªÜU R·ª¶I RO - ƒêi·ªÉm: ${finalScore}/100`,
        details
      );
      addLog('TH√îNG TIN: C√≥ t√≠n hi·ªáu r·ªßi ro nh∆∞ng ch∆∞a ƒë·ªß m·∫°nh ƒë·ªÉ k·∫øt lu·∫≠n ƒëa k√™nh');
    } else {
      showAlert(
        'low',
        `‚úÖ R·ª¶I RO TH·∫§P - ƒêi·ªÉm: ${finalScore}/100`,
        details
      );
      addLog('TH√îNG TIN: R·ªßi ro th·∫•p, kh√¥ng th·∫•y ph·ªëi h·ª£p ƒëa k√™nh r√µ r√†ng');
    }

    updateMetrics(finalScore);
    addLog('Ph√¢n t√≠ch t√≠ch h·ª£p ƒëa k√™nh ho√†n t·∫•t');
  }, 1200);
}


        // ========== H√ÄM H·ªñ TR·ª¢ PH√ÇN T√çCH T√çCH H·ª¢P ==========
        function findMultiChannelEntities(entityType) {
            const connections = [];
            const entityCount = {};
            
            // ƒê·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán c·ªßa m·ªói th·ª±c th·ªÉ tr√™n c√°c k√™nh
            Object.keys(entityGraph.channels).forEach(channel => {
                entityGraph.channels[channel][entityType].forEach(entity => {
                    if (!entityCount[entity]) {
                        entityCount[entity] = { count: 0, channels: [] };
                    }
                    entityCount[entity].count++;
                    if (!entityCount[entity].channels.includes(channel)) {
                        entityCount[entity].channels.push(channel);
                    }
                });
            });
            
            // T√¨m c√°c th·ª±c th·ªÉ xu·∫•t hi·ªán tr√™n nhi·ªÅu k√™nh
            Object.keys(entityCount).forEach(entity => {
                if (entityCount[entity].count > 1) {
                    connections.push({
                        entity: entity,
                        count: entityCount[entity].count,
                        channels: entityCount[entity].channels
                    });
                }
            });
            
            return connections;
        }

       function analyzeBehaviorPatterns() {
  const patterns = [];

  const hasSMSWithURL  = entityGraph.channels.sms.urls.size > 0;
  const hasURLWithPhone = entityGraph.channels.url.phones.size > 0;
  const hasCallWithURL = entityGraph.channels.call.urls.size > 0;

  if (hasSMSWithURL && hasURLWithPhone) {
    patterns.push('SMS ch·ª©a URL ‚Üí URL ch·ª©a SƒêT (m·∫´u d·∫´n d·ª• ƒëi·ªÉn h√¨nh)');
  }
  if (hasCallWithURL && hasURLWithPhone) {
    patterns.push('Cu·ªôc g·ªçi ƒë·ªÅ c·∫≠p URL ‚Üí URL ch·ª©a SƒêT (m·∫´u x√°c nh·∫≠n)');
  }

  // ‚úÖ l·∫•y "t·∫≠p keyword chung" b·∫±ng c√°ch union 3 k√™nh
  const allKeywords = new Set([
    ...entityGraph.channels.url.keywords,
    ...entityGraph.channels.sms.keywords,
    ...entityGraph.channels.call.keywords
  ]);

  allKeywords.forEach(keyword => {
    const appearIn = [];
    if (entityGraph.channels.url.keywords.has(keyword)) appearIn.push('url');
    if (entityGraph.channels.sms.keywords.has(keyword)) appearIn.push('sms');
    if (entityGraph.channels.call.keywords.has(keyword)) appearIn.push('call');

    if (appearIn.length > 1) {
      patterns.push(`T·ª´ kh√≥a "${keyword}" xu·∫•t hi·ªán nh·∫•t qu√°n tr√™n ${appearIn.length} k√™nh`);
    }
  });

  return patterns;
}
function getUniqueEntitiesForChannel(channel, type) {
  const current = new Set(entityGraph.channels[channel][type]);
  const others = new Set();

  Object.keys(entityGraph.channels).forEach(ch => {
    if (ch === channel) return;
    entityGraph.channels[ch][type].forEach(v => others.add(v));
  });

  const unique = [];
  current.forEach(v => { if (!others.has(v)) unique.push(v); });

  const shared = [];
  current.forEach(v => { if (others.has(v)) shared.push(v); });

  return { unique, shared };
}

function pickHighlights(channel) {
  const p = getUniqueEntitiesForChannel(channel, 'phones');
  const u = getUniqueEntitiesForChannel(channel, 'urls');
  const k = getUniqueEntitiesForChannel(channel, 'keywords');

  // ∆Øu ti√™n unique tr∆∞·ªõc, n·∫øu kh√¥ng c√≥ th√¨ l·∫•y shared + g·∫Øn nh√£n
  const phone = (p.unique[0] ?? p.shared[0]) || '';
  const phoneTag = p.unique[0] ? '' : (p.shared[0] ? ' (tr√πng ƒëa k√™nh)' : '');

  const url = (u.unique[0] ?? u.shared[0]) || '';
  const urlTag = u.unique[0] ? '' : (u.shared[0] ? ' (tr√πng ƒëa k√™nh)' : '');

  // keyword: l·∫•y t·ªëi ƒëa 2 c√°i unique, n·∫øu kh√¥ng c√≥ unique th√¨ l·∫•y shared
  const kwList = k.unique.length ? k.unique.slice(0, 2) : k.shared.slice(0, 2);
  const kwTag = k.unique.length ? '' : (k.shared.length ? ' (tr√πng ƒëa k√™nh)' : '');

  return { phone, phoneTag, url, urlTag, kwList, kwTag };
}

        function showVisualization() {
  const visualization = document.getElementById('visualization');
  const entityGraphContainer = document.getElementById('entityGraph');

  visualization.style.display = 'block';

  let html = '';

  Object.keys(entityGraph.channels).forEach(channel => {
    const channelName = channel.toUpperCase();

    const phonesArr = Array.from(entityGraph.channels[channel].phones);
    const urlsArr   = Array.from(entityGraph.channels[channel].urls);
    const keysArr   = Array.from(entityGraph.channels[channel].keywords);

   const coreEntityCount = phonesArr.length + urlsArr.length;

    html += `
      <div class="entity-node node-${channel}">
        <h4>${channelName}</h4>
        <p>
  Th·ª±c th·ªÉ: ${coreEntityCount}<br>
  D·∫•u hi·ªáu: ${keysArr.length}
</p>
        <div style="font-size: 12px; margin-top: 5px;">
          ${phonesArr.length ? 'üìû ' + phonesArr[0] + (phonesArr.length > 1 ? '...' : '') + '<br>' : ''}
          ${urlsArr.length ? 'üåê ' + (urlsArr[0].substring(0, 30)) + '...<br>' : ''}
          ${keysArr.length ? 'üîë ' + keysArr.slice(0, 2).join(', ') + (keysArr.length > 2 ? '...' : '') : ''}
        </div>
      </div>
    `;
  });

  entityGraphContainer.innerHTML = html;

  setTimeout(addConnectionLines, 100);
}

        function addConnectionLines() {
            const connections = [
                ...findMultiChannelEntities('phones'),
                ...findMultiChannelEntities('urls'),
                ...findMultiChannelEntities('keywords')
            ];
            
            connections.forEach(conn => {
                if (conn.channels.length > 1) {
                    const line = document.createElement('div');
                    line.className = 'connection-line';
                    line.style.width = '100%';
                    line.innerHTML = `<div class="connection-label">${conn.entity.substring(0, 20)}...</div>`;
                    document.getElementById('entityGraph').appendChild(line);
                }
            });
        }

        // ========== H√ÄM KH√ÅC ==========
        function selectChannel(channel) {
            addLog(`ƒê√£ ch·ªçn k√™nh: ${channel.toUpperCase()}`);
            
            // L√†m n·ªïi b·∫≠t k√™nh ƒë∆∞·ª£c ch·ªçn
            document.querySelectorAll('.channel').forEach(ch => {
                ch.style.transform = 'scale(1)';
                ch.style.boxShadow = '';
            });
            
            event.target.style.transform = 'scale(1.05)';
            event.target.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
        }

        // Kh·ªüi t·∫°o demo
        document.addEventListener('DOMContentLoaded', function() {
            addLog('H·ªá th·ªëng Ph√°t hi·ªán L·ª´a ƒë·∫£o ƒêa k√™nh ƒë√£ kh·ªüi t·∫°o');
            addLog('T·∫•t c·∫£ m√¥-ƒëun ti·ªÅn x·ª≠ l√Ω ƒë√£ t·∫£i th√†nh c√¥ng');
            addLog('B·ªô ƒë√°nh gi√° R·ªßi ro AI ƒë√£ ƒë∆∞·ª£c hi·ªáu ch·ªânh');
            addLog('Ph√¢n t√≠ch li√™n k√™nh s·∫µn s√†ng');
            addLog('H·ªá th·ªëng s·∫µn s√†ng ph√°t hi·ªán m·ªëi ƒëe d·ªça');
        });

        // M√¥ ph·ªèng gi√°m s√°t th·ªùi gian th·ª±c
        setInterval(() => {
            const activities = [
                'ƒêang ch·∫°y ph√¢n t√≠ch t∆∞∆°ng quan li√™n k√™nh...',
                'ƒê√£ c·∫≠p nh·∫≠t ƒë·ªì th·ªã quan h·ªá th·ª±c th·ªÉ',
                'ƒê√£ ph√¢n t√≠ch m·∫´u h√†nh tr√¨nh ng∆∞·ªùi d√πng',
                'ƒê√£ hi·ªáu ch·ªânh l·∫°i m√¥ h√¨nh t√≠nh ƒëi·ªÉm r·ªßi ro',
                'ƒê√£ c·∫≠p nh·∫≠t ngu·ªìn c·∫•p d·ªØ li·ªáu t√¨nh b√°o m·ªëi ƒëe d·ªça',
                'ƒê√£ ƒë√°nh gi√° c√°c k√≠ch ho·∫°t c·∫£nh b√°o s·ªõm'
            ];
            
            const randomActivity = activities[Math.floor(Math.random() * activities.length)];
            if (Math.random() > 0.7) { // 30% x√°c su·∫•t
                addLog(randomActivity);
            }
        }, 5000);
    </script>
</body>
</html>